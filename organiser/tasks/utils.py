import random
import string
import datetime
from django.contrib.auth.models import User
from organiser.tasks.models import Task
from organiser.tasks.sample_tasks import SAMPLE_TASK_NAMES


class RandomTaskGenerator(object):
    """
    Generates random tasks. Requires there to be a superuser.
    Randomly generated tasks are by default generated by their owners.

    NB: Something like django-autofixture app could also be used for test data generation
    """
    def __init__(self, predefined_names=True, owners=None):
        self.predefined_names = predefined_names

        name_max_length = Task._meta.get_field('name').max_length
        self.name_min_length = min(5, name_max_length)  # name_max_length can be less than 5
        self.name_max_length = name_max_length

        description_max_length = Task._meta.get_field('description').max_length or 100  # description_max_length may or may not be defined
        self.description_min_length = min(20, description_max_length)  # description_max_length can be less than 20
        self.description_max_length = description_max_length

        self.owners = owners
        if not self.owners:
            self.owners = [User.objects.get(is_superuser=True)]

    def generate(self, number=5, save=False):
        tasks = []
        for _ in range(number):
            tasks.append(self.generate_task())

        if save:
            Task.objects.bulk_create(tasks)

    def generate_task(self):
        owner = self._generate_owner()
        task = Task(
            name=self._generate_name(),
            description=self._generate_description(),
            status=self._generate_status(),
            due_datetime=self._generate_due_datetime(),
            owner=owner,
            create_user=owner,
            update_user=owner,
            archived=self._generate_archived()
        )
        return task

    def _generate_name(self):
        if not self.predefined_names:
            chars = []
            for _ in range(random.randint(self.name_min_length, self.name_max_length)):
                chars.append(random.choice(string.ascii_letters))
            return ''.join(chars)
        else:
            return SAMPLE_TASK_NAMES[random.randint(0, len(SAMPLE_TASK_NAMES) - 1)]

    def _generate_description(self):
        chars = []
        for _ in range(random.randint(self.description_min_length, self.description_max_length)):
            chars.append(random.choice(string.ascii_letters))
        return ''.join(chars)

    def _generate_status(self):
        return random.randint(0, len(Task.STATUS.values()) - 1)

    def _generate_due_datetime(self):
        """
        Generates either future of past dates.
        This is handled by the 'signs' dict and 'sign' value (-1 or 1).
        The maximum possible offset from now (either in future or past) is
        at most 1 week (6 days + 23 hours + 60 minutes).
        """
        signs = {
            0: 1,
            1: -1
        }
        sign = signs[random.randint(0, 1)]

        days = random.randint(0, 6) * sign
        hours = random.randint(0, 23) * sign
        minutes = random.randint(0, 60) * sign

        total_minutes_offset = (days * 24 * 60) + (hours * 60) + minutes
        return datetime.datetime.utcnow() + datetime.timedelta(minutes=total_minutes_offset)

    def _generate_owner(self):
        return self.owners[random.randint(0, len(self.owners) - 1)]

    def _generate_archived(self):
        return bool(random.randint(0, 1))


